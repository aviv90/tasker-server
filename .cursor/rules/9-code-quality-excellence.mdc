---
description: Comprehensive code quality standards - clean, modular, optimal, following all best practices
globs:
  - "**/*.js"
  - "services/**"
  - "routes/**"
  - "utils/**"
  - "config/**"
---

# Code Quality Excellence

## Core Philosophy

**Every line of code must be clean, optimal, modular, and maintainable.**

Code should be:
- Easy to read and understand
- Easy to modify and extend
- Easy to test and debug
- Performant and efficient
- Following industry best practices

---

## SOLID Principles

### 1. Single Responsibility Principle (SRP)
**Each module/class/function does ONE thing only.**

âœ… **Good:**
```javascript
// services/imageService.js - handles ONLY image operations
async function generateImage(prompt) { ... }
async function editImage(imageUrl, prompt) { ... }

// services/videoService.js - handles ONLY video operations
async function generateVideo(prompt) { ... }
```

âŒ **Bad:**
```javascript
// services/mediaService.js - handles too much!
async function generateImage(prompt) { ... }
async function generateVideo(prompt) { ... }
async function transcribeAudio(audioUrl) { ... }
async function translateText(text) { ... }
```

### 2. Open/Closed Principle
**Open for extension, closed for modification.**

âœ… **Good:** Use strategy pattern
```javascript
const providers = {
  gemini: () => generateWithGemini(prompt),
  openai: () => generateWithOpenAI(prompt),
  grok: () => generateWithGrok(prompt)
};

// Easy to add new provider without modifying existing code
const result = await providers[provider]();
```

### 3. Dependency Inversion
**Depend on abstractions, not concretions.**

âœ… **Good:**
```javascript
async function sendNotification(service, message) {
  await service.send(message); // Depends on interface
}
```

---

## DRY (Don't Repeat Yourself)

**Never duplicate code. Extract common logic into reusable functions.**

âŒ **Bad:** Repetition
```javascript
// In file A
if (agentResult.multiStep && agentResult.alreadySent) {
  console.log('Skipping...');
  return;
}

// In file B - SAME CODE!
if (agentResult.multiStep && agentResult.alreadySent) {
  console.log('Skipping...');
  return;
}
```

âœ… **Good:** Extracted utility
```javascript
// utils/agentUtils.js
function shouldSkipSending(agentResult) {
  return agentResult.multiStep && agentResult.alreadySent;
}

// Usage in both files
if (shouldSkipSending(agentResult)) {
  console.log('Skipping...');
  return;
}
```

---

## Single Source of Truth (SSOT)

**CRITICAL: All data, configuration, and definitions MUST have exactly ONE authoritative source.**

Never duplicate data structures, lists, constants, or configurations across files.

### Rule: One Definition, Many References

âŒ **Bad:** Duplicated tool lists
```javascript
// prompts.js
const tools = ['create_image', 'create_video', 'search_web', 'create_music'];

// agentService.js - DUPLICATION!
const availableTools = ['create_image', 'create_video', 'search_web', 'create_music'];

// constants.js - MORE DUPLICATION!
const toolNames = ['create_image', 'create_video', 'search_web', 'create_music'];
```

âœ… **Good:** Single source, multiple consumers
```javascript
// config/tools-list.js - THE ONLY SOURCE
const TOOLS = {
  create_image: { name: 'create_image', description: '...' },
  create_video: { name: 'create_video', description: '...' },
  search_web: { name: 'search_web', description: '...' },
  create_music: { name: 'create_music', description: '...' }
};

module.exports = { TOOLS };

// prompts.js - CONSUMES from SSOT
const { TOOLS } = require('./tools-list');
const toolsList = Object.keys(TOOLS).join(', ');

// agentService.js - CONSUMES from SSOT
const { TOOLS } = require('../config/tools-list');
const availableTools = Object.values(TOOLS);

// constants.js - CONSUMES from SSOT
const { TOOLS } = require('../../config/tools-list');
const toolNames = Object.keys(TOOLS);
```

### Examples of SSOT Violations to Avoid:

1. **Tool Definitions**: Define once in `config/tools-list.js`, import everywhere
2. **Provider Names**: Define once in `config/providers.js`, import everywhere
3. **Language Instructions**: Define once in `config/prompts.js`, import everywhere
4. **Error Messages**: Define once in `config/messages.js`, import everywhere
5. **API Endpoints**: Define once in `config/api.js`, import everywhere
6. **Validation Rules**: Define once in `utils/validation.js`, import everywhere

### Benefits of SSOT:

1. **Consistency**: Change once, updates everywhere automatically
2. **Maintainability**: No need to hunt for duplicates when updating
3. **Type Safety**: Single definition ensures all consumers use same structure
4. **Reduced Bugs**: Impossible to have inconsistent versions
5. **Clear Ownership**: One file = one responsibility

### Refactoring Checklist for SSOT:

When you find duplicated data:

1. âœ… Create a central config file (e.g., `config/tools-list.js`)
2. âœ… Move ALL instances of the data to this ONE file
3. âœ… Export utility functions to format/filter the data as needed
4. âœ… Update all consumers to import from the central file
5. âœ… Verify no duplicates remain (grep for patterns)
6. âœ… Document the SSOT location in comments if non-obvious

### Warning Signs of SSOT Violation:

ğŸš¨ Same list appears in multiple files
ğŸš¨ Same constant defined in different places
ğŸš¨ Similar data structures with slight differences
ğŸš¨ When updating, need to change multiple files
ğŸš¨ Comments like "keep in sync with..."

**If you see these signs, immediately refactor to SSOT!**

---

## Separation of Concerns

**Each file/module handles ONE specific domain.**

### File Organization Rules:

1. **Services** (`services/`) - Business logic, external API calls
2. **Routes** (`routes/`) - HTTP handlers, request/response only
3. **Utils** (`utils/`) - Pure functions, no side effects
4. **Config** (`config/`) - Configuration, constants, prompts
5. **Models** (`models/`) - Data structures, database schemas

âŒ **Bad:** Mixed concerns
```javascript
// routes/whatsappRoutes.js
// âŒ Business logic in route handler!
router.post('/webhook', (req, res) => {
  const imageUrl = await generateImageWithGemini(prompt); // â† Should be in service!
  const text = translateText(imageUrl.caption, 'he'); // â† Should be in service!
  await sendToWhatsApp(chatId, imageUrl);
});
```

âœ… **Good:** Clear separation
```javascript
// routes/whatsappRoutes.js - Only routing
router.post('/webhook', async (req, res) => {
  const result = await agentService.processRequest(req.body);
  res.json(result);
});

// services/agentService.js - Business logic
async function processRequest(data) {
  const imageUrl = await imageService.generate(prompt);
  const text = await translationService.translate(imageUrl.caption, 'he');
  await whatsappService.send(chatId, imageUrl);
}
```

---

## Modularity & File Size

### ğŸš¨ CRITICAL: Keep Files Small and Focused

**NEVER allow files to become bloated monoliths.**

### Strict File Size Limits:

| Metric | Maximum | Ideal | Action if Exceeded |
|--------|---------|-------|-------------------|
| **Lines per file** | 500 | 200-300 | **MUST SPLIT** |
| **Lines per function** | 50 | 10-20 | Extract sub-functions |
| **Parameters per function** | 5 | 2-3 | Use object parameter |
| **Exports per file** | 10 | 3-5 | Split into multiple files |
| **Nesting depth** | 4 | 2-3 | Extract nested logic |

### Red Flags - Immediate Refactoring Required:

ğŸš¨ **File > 500 lines** â†’ Split immediately  
ğŸš¨ **Function > 50 lines** â†’ Extract sub-functions  
ğŸš¨ **Too many scroll pages** â†’ Hard to maintain  
ğŸš¨ **Multiple domains in one file** â†’ Violates SRP  
ğŸš¨ **Can't find code quickly** â†’ Poor organization  

### When to Split a File:

âœ… **Split when:**
1. File exceeds 500 lines
2. Multiple unrelated responsibilities (violates SRP)
3. Too many exports (>10)
4. Hard to navigate or find code
5. Takes > 5 seconds to locate a function
6. Mixing different concerns (routes + logic)

### How to Split Files:

**Step 1:** Identify domains/responsibilities
```javascript
// Before: services/agentService.js (3900 lines) âŒ
// - Tool definitions
// - Execution logic
// - Ack messages
// - Context building
// - Multi-step planning
```

**Step 2:** Create domain-specific modules
```
services/agent/
  â”œâ”€â”€ agentService.js        # Orchestration ONLY (max 300 lines) âœ…
  â”œâ”€â”€ tools/
  â”‚   â”œâ”€â”€ imageTools.js      # Image-related tools
  â”‚   â”œâ”€â”€ searchTools.js     # Search-related tools
  â”‚   â””â”€â”€ locationTools.js   # Location-related tools
  â”œâ”€â”€ execution/
  â”‚   â”œâ”€â”€ singleStep.js      # Single step execution
  â”‚   â””â”€â”€ multiStep.js       # Multi-step execution
  â””â”€â”€ utils/
      â”œâ”€â”€ ackMessages.js     # Ack message building
      â””â”€â”€ contextBuilder.js  # Context building
```

**Step 3:** Main file becomes thin orchestrator
```javascript
// agentService.js - Now clean and focused! âœ…
const { imageTools } = require('./tools/imageTools');
const { singleStep } = require('./execution/singleStep');
const { buildAck } = require('./utils/ackMessages');

async function executeAgent(request) {
  const ack = buildAck(request);
  await sendAck(ack);
  return await singleStep.execute(request);
}
```

### Benefits of Small Files:

âœ… **Easy Navigation**: Find code in seconds  
âœ… **Clear Purpose**: Each file has ONE job  
âœ… **Easy Testing**: Small, focused units  
âœ… **Better Git**: Smaller, clearer diffs  
âœ… **Faster Reviews**: Quick to understand changes  
âœ… **Reduced Bugs**: Less complexity = fewer bugs  

### Real-World Examples from Our Codebase:

#### âœ… **Success Story:**
```
gemini/core.js: 2724 lines â†’ Split into 4 modules:
  - imageGeneration.js (509 lines)
  - videoGeneration.js (765 lines)
  - textOperations.js (688 lines)
  - specialOperations.js (820 lines)
Result: -100% monolith, +400% maintainability
```

#### âœ… **Success Story:**
```
agentService.js: 4187 lines â†’ Reduced to 880 lines (-79%)
Extracted:
  - metaTools.js (3012 lines)
  - singleStep.js (233 lines)
  - ackUtils.js (136 lines)
Result: Thin orchestrator, clear responsibilities
```

---

## Code Complexity

### Cyclomatic Complexity Limits:
- **Maximum complexity: 10** per function
- **Ideal complexity: 1-5**

âŒ **Bad:** Too complex (complexity > 15)
```javascript
function processRequest(data) {
  if (data.type === 'text') {
    if (data.multiStep) {
      if (data.steps.length > 1) {
        for (let step of data.steps) {
          if (step.tool === 'image') {
            if (step.provider === 'gemini') {
              // ... 20 more nested ifs
            }
          }
        }
      }
    }
  }
}
```

âœ… **Good:** Low complexity (complexity < 5)
```javascript
function processRequest(data) {
  if (!isValid(data)) return handleError();
  
  return data.multiStep 
    ? processMultiStep(data)
    : processSingleStep(data);
}

function processMultiStep(data) {
  return data.steps.map(executeStep);
}
```

---

## Naming Conventions

### Variables & Functions:
- **camelCase** for variables/functions: `getUserData`, `isValid`
- **PascalCase** for classes: `UserService`, `ImageGenerator`
- **UPPER_SNAKE_CASE** for constants: `MAX_RETRIES`, `API_KEY`

### Naming Rules:
1. **Descriptive, not cryptic**: `userData` not `ud`
2. **Verbs for functions**: `generateImage`, `validateInput`
3. **Nouns for variables**: `userList`, `imageUrl`
4. **Boolean prefixes**: `isValid`, `hasError`, `shouldRetry`

âŒ **Bad:**
```javascript
function proc(d) {
  const x = d.t;
  const y = gen(x);
  return y;
}
```

âœ… **Good:**
```javascript
function processUserRequest(data) {
  const userText = data.text;
  const response = generateResponse(userText);
  return response;
}
```

---

## Error Handling

### Always Handle Errors Gracefully:

âœ… **Good:**
```javascript
try {
  const result = await riskyOperation();
  return result;
} catch (error) {
  console.error('âŒ Operation failed:', error.message);
  // Send error to user (Rule 2)
  await sendErrorToUser(chatId, error.message);
  return { success: false, error: error.message };
}
```

âŒ **Bad:**
```javascript
const result = await riskyOperation(); // â† No error handling!
```

---

## Performance Optimization

### 1. Avoid Unnecessary Work:
```javascript
// âœ… Good: Early return
if (!data) return;
if (!isValid(data)) return;
// ... expensive operations

// âŒ Bad: Do work then check
const result = expensiveOperation(data);
if (!data) return;
```

### 2. Use Caching:
```javascript
// âœ… Good: Cache expensive results
const cache = new Map();
function getExpensiveData(key) {
  if (cache.has(key)) return cache.get(key);
  const data = computeExpensiveData(key);
  cache.set(key, data);
  return data;
}
```

### 3. Parallelize Independent Operations:
```javascript
// âœ… Good: Parallel
const [image, video, audio] = await Promise.all([
  generateImage(prompt),
  generateVideo(prompt),
  generateAudio(prompt)
]);

// âŒ Bad: Sequential (3x slower!)
const image = await generateImage(prompt);
const video = await generateVideo(prompt);
const audio = await generateAudio(prompt);
```

---

## Code Comments

### When to Comment:
1. **Why**, not what: Explain reasoning, not obvious behavior
2. **Complex algorithms**: Explain the approach
3. **Workarounds**: Why you did something unusual
4. **TODOs**: What needs to be done (with context)

âœ… **Good:**
```javascript
// CRITICAL: Must send Ack BEFORE execution to prevent race condition
// where user sees output before knowing what's happening
await sendAck(chatId, tool);
await executeTool(tool);
```

âŒ **Bad:**
```javascript
// Send ack
await sendAck(chatId, tool); // â† Obvious!
```

---

## Testing Mindset

**Code should be written to be testable.**

âœ… **Testable:**
```javascript
// Pure function - easy to test
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

âŒ **Hard to test:**
```javascript
// Side effects everywhere
function processOrder() {
  const items = getItemsFromDatabase(); // â† Hard to mock
  const total = items.reduce((sum, item) => sum + item.price, 0);
  saveToDatabase(total); // â† Side effect
  sendEmail(user.email, total); // â† Side effect
}
```

---

## Refactoring Indicators

**Refactor when you see:**

1. ğŸš¨ **God Objects** - File/class doing too much
2. ğŸš¨ **Code Duplication** - Same logic in multiple places
3. ğŸš¨ **Long Functions** - Functions > 50 lines
4. ğŸš¨ **Deep Nesting** - Indentation > 4 levels
5. ğŸš¨ **Magic Numbers** - Unexplained constants in code
6. ğŸš¨ **Long Parameter Lists** - Functions with > 5 parameters
7. ğŸš¨ **Unclear Names** - Variables like `x`, `temp`, `data`

---

## Summary Checklist

Before committing, ask yourself:

- [ ] Is each file under 500 lines?
- [ ] Is each function under 50 lines?
- [ ] Does each module have a single responsibility?
- [ ] Is there any duplicated code? (DRY)
- [ ] Is there a Single Source of Truth for all data/config? (SSOT)
- [ ] Are all functions and variables named clearly?
- [ ] Is error handling comprehensive?
- [ ] Are concerns properly separated?
- [ ] Is the code optimized (no unnecessary work)?
- [ ] Would this be easy to test?
- [ ] Would a new developer understand this code?
- [ ] Can I reuse this code in other contexts? (Maximize reusability)

**If any answer is "no", refactor before committing.**

---

## Prompts & Acknowledgments Separation

**CRITICAL: All prompts and acknowledgment messages MUST be separated from business logic.**

This enforces SSOT and ensures consistency across all execution paths.

### Prompts Separation Rules:

1. **ALL prompts in `config/prompts.js`**:
   - System instructions for LLMs (Gemini, OpenAI, Grok)
   - Multi-step planner prompts
   - Agent routing prompts
   - Tool descriptions and examples
   
2. **Tool definitions in `config/tools-list.js`**:
   - Single source of truth for all tools
   - Descriptions, parameters, usage patterns
   - No duplication in other files

3. **Never hardcode prompts** in service files:

âŒ **Bad:**
```javascript
// services/imageService.js
const prompt = "Generate an image based on this description..."; // â† Hardcoded!
const result = await gemini.generate(prompt);
```

âœ… **Good:**
```javascript
// config/prompts.js
module.exports = {
  imageGeneration: (userPrompt) => `Generate an image: ${userPrompt}`
};

// services/imageService.js
const { imageGeneration } = require('../config/prompts');
const prompt = imageGeneration(userPrompt);
const result = await gemini.generate(prompt);
```

### Acknowledgment Messages (Acks) Rules:

**MUST be consistent across single-step AND multi-step execution.**

1. **Centralized Ack storage**:
   - WhatsApp Acks: `services/whatsapp/messaging.js` (sendAck function)
   - Agent Acks: `services/agent/config/constants.js` (TOOL_ACK_MESSAGES)

2. **Include provider names** where relevant:
   ```javascript
   TOOL_ACK_MESSAGES: {
     create_image: 'ğŸ¨ ×™×•×¦×¨ ×ª××•× ×” ×¢× __PROVIDER__...',
     create_video: 'ğŸ¬ ×™×•×¦×¨ ×•×™×“××• ×¢× __PROVIDER__...',
     edit_video: 'ğŸï¸ ×¢×•×¨×š ×•×™×“××• ×¢× Runway...' // Fixed provider
   }
   ```

3. **Same format for all paths**:
   - Single-step commands â†’ Use same Ack format
   - Multi-step commands â†’ Use same Ack format
   - Fallback attempts â†’ Send Ack for each provider

### Benefits:

âœ… **Maintainability**: Change once, apply everywhere  
âœ… **Consistency**: Same UX across all execution paths  
âœ… **Testability**: Easy to test prompt/Ack changes  
âœ… **Clarity**: Business logic stays clean  
âœ… **SSOT**: Single source for all user-facing text  

### Example: Wrong vs. Right

âŒ **Wrong:** Different Acks for same operation
```javascript
// Single-step handler
await sendTextMessage(chatId, 'ğŸ¨ ×§×™×‘×œ×ª×™! ××™×™×¦×¨ ×ª××•× ×”...'); // Different!

// Multi-step handler
await sendTextMessage(chatId, 'ğŸ¨ ×™×•×¦×¨ ×ª××•× ×” ×¢× Gemini...'); // Different!
```

âœ… **Right:** Consistent Acks everywhere
```javascript
// Both use the same central function
await sendAck(chatId, { type: 'create_image', provider: 'gemini' });
// â†’ "ğŸ¨ ×™×•×¦×¨ ×ª××•× ×” ×¢× Gemini..."
```

---

## Media Handling - CRITICAL Rule

**CRITICAL: If media URLs are present in provider response, they MUST be sent to the user!**

### Media Delivery Requirements:

1. **Mandatory Media Sending**:
   - If `imageUrl` exists in response â†’ MUST send image via WhatsApp
   - If `videoUrl` exists in response â†’ MUST send video via WhatsApp
   - If `audioUrl` exists in response â†’ MUST send audio via WhatsApp
   - **NEVER send URLs as text instead of actual media!**

2. **Media Types Supported**:
   - ğŸ–¼ï¸ **Images**: `imageUrl` â†’ Use `sendFileByUrl()` or `sendImage()`
   - ğŸ¬ **Videos**: `videoUrl` â†’ Use `sendFileByUrl()` or `sendVideo()`
   - ğŸ¤ **Audio**: `audioUrl` â†’ Use `sendFileByUrl()` or `sendAudio()`

3. **URL Handling**:
   - Provider returns URL â†’ Download and send as file
   - Provider returns buffer â†’ Save to temp file, then send
   - **NEVER** send URL string in text message (user can't access it!)

âŒ **Bad:** Sending URL as text instead of media
```javascript
// âŒ WRONG - User gets text link, not actual media!
if (result.imageUrl) {
  await sendTextMessage(chatId, `Here's your image: ${result.imageUrl}`);
}
```

âœ… **Good:** Always send actual media
```javascript
// âœ… CORRECT - User gets actual image file
if (result.imageUrl) {
  console.log(`ğŸ“¸ Sending generated image: ${result.imageUrl}`);
  await sendFileByUrl(chatId, result.imageUrl, 'image', {
    caption: result.imageCaption || ''
  });
}
```

âœ… **Good:** Handle both URL and buffer cases
```javascript
if (result.imageUrl) {
  await sendFileByUrl(chatId, result.imageUrl, 'image', {
    caption: result.imageCaption || ''
  });
} else if (result.imageBuffer) {
  // Save buffer to temp file first
  const tempPath = await saveBufferToTempFile(result.imageBuffer, 'image.jpg');
  const tempUrl = `${host}/static/${path.basename(tempPath)}`;
  await sendFileByUrl(chatId, tempUrl, 'image');
}
```

### Error Handling for Media:

- If media download fails â†’ Log error AND notify user
- If media send fails â†’ Log error AND notify user  
- **Always inform user** if media operation fails (Rule 2: Send errors as-is)

### Priority Order:

1. **Media URLs** (highest priority) â†’ Send immediately
2. **Text response** â†’ Send after media, or separately
3. **Captions** â†’ Attach to media if possible

### Benefits:

âœ… **Better UX**: Users get actual media files, not broken links  
âœ… **Reliability**: Media is accessible even if URLs expire  
âœ… **Consistency**: Same behavior across all providers  
âœ… **User Trust**: Media always delivered as expected  

---

## Further Reading

- Clean Code by Robert C. Martin
- Refactoring by Martin Fowler
- Design Patterns by Gang of Four
- JavaScript: The Good Parts by Douglas Crockford
