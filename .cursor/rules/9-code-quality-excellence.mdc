---
description: Comprehensive code quality standards - clean, modular, optimal, following all best practices
globs:
  - "**/*.js"
  - "services/**"
  - "routes/**"
  - "utils/**"
  - "config/**"
---

# Code Quality Excellence

## Core Philosophy

**Every line of code must be clean, optimal, modular, and maintainable.**

Code should be:
- Easy to read and understand
- Easy to modify and extend
- Easy to test and debug
- Performant and efficient
- Following industry best practices

---

## SOLID Principles

### 1. Single Responsibility Principle (SRP)
**Each module/class/function does ONE thing only.**

âœ… **Good:**
```javascript
// services/imageService.js - handles ONLY image operations
async function generateImage(prompt) { ... }
async function editImage(imageUrl, prompt) { ... }

// services/videoService.js - handles ONLY video operations
async function generateVideo(prompt) { ... }
```

âŒ **Bad:**
```javascript
// services/mediaService.js - handles too much!
async function generateImage(prompt) { ... }
async function generateVideo(prompt) { ... }
async function transcribeAudio(audioUrl) { ... }
async function translateText(text) { ... }
```

### 2. Open/Closed Principle
**Open for extension, closed for modification.**

âœ… **Good:** Use strategy pattern
```javascript
const providers = {
  gemini: () => generateWithGemini(prompt),
  openai: () => generateWithOpenAI(prompt),
  grok: () => generateWithGrok(prompt)
};

// Easy to add new provider without modifying existing code
const result = await providers[provider]();
```

### 3. Dependency Inversion
**Depend on abstractions, not concretions.**

âœ… **Good:**
```javascript
async function sendNotification(service, message) {
  await service.send(message); // Depends on interface
}
```

---

## DRY (Don't Repeat Yourself)

**Never duplicate code. Extract common logic into reusable functions.**

âŒ **Bad:** Repetition
```javascript
// In file A
if (agentResult.multiStep && agentResult.alreadySent) {
  console.log('Skipping...');
  return;
}

// In file B - SAME CODE!
if (agentResult.multiStep && agentResult.alreadySent) {
  console.log('Skipping...');
  return;
}
```

âœ… **Good:** Extracted utility
```javascript
// utils/agentUtils.js
function shouldSkipSending(agentResult) {
  return agentResult.multiStep && agentResult.alreadySent;
}

// Usage in both files
if (shouldSkipSending(agentResult)) {
  console.log('Skipping...');
  return;
}
```

---

## Single Source of Truth (SSOT)

**CRITICAL: All data, configuration, and definitions MUST have exactly ONE authoritative source.**

Never duplicate data structures, lists, constants, or configurations across files.

### Rule: One Definition, Many References

âŒ **Bad:** Duplicated tool lists
```javascript
// prompts.js
const tools = ['create_image', 'create_video', 'search_web', 'create_music'];

// agentService.js - DUPLICATION!
const availableTools = ['create_image', 'create_video', 'search_web', 'create_music'];

// constants.js - MORE DUPLICATION!
const toolNames = ['create_image', 'create_video', 'search_web', 'create_music'];
```

âœ… **Good:** Single source, multiple consumers
```javascript
// config/tools-list.js - THE ONLY SOURCE
const TOOLS = {
  create_image: { name: 'create_image', description: '...' },
  create_video: { name: 'create_video', description: '...' },
  search_web: { name: 'search_web', description: '...' },
  create_music: { name: 'create_music', description: '...' }
};

module.exports = { TOOLS };

// prompts.js - CONSUMES from SSOT
const { TOOLS } = require('./tools-list');
const toolsList = Object.keys(TOOLS).join(', ');

// agentService.js - CONSUMES from SSOT
const { TOOLS } = require('../config/tools-list');
const availableTools = Object.values(TOOLS);

// constants.js - CONSUMES from SSOT
const { TOOLS } = require('../../config/tools-list');
const toolNames = Object.keys(TOOLS);
```

### Examples of SSOT Violations to Avoid:

1. **Tool Definitions**: Define once in `config/tools-list.js`, import everywhere
2. **Provider Names**: Define once in `config/providers.js`, import everywhere
3. **Language Instructions**: Define once in `config/prompts.js`, import everywhere
4. **Error Messages**: Define once in `config/messages.js`, import everywhere
5. **API Endpoints**: Define once in `config/api.js`, import everywhere
6. **Validation Rules**: Define once in `utils/validation.js`, import everywhere

### Benefits of SSOT:

1. **Consistency**: Change once, updates everywhere automatically
2. **Maintainability**: No need to hunt for duplicates when updating
3. **Type Safety**: Single definition ensures all consumers use same structure
4. **Reduced Bugs**: Impossible to have inconsistent versions
5. **Clear Ownership**: One file = one responsibility

### Refactoring Checklist for SSOT:

When you find duplicated data:

1. âœ… Create a central config file (e.g., `config/tools-list.js`)
2. âœ… Move ALL instances of the data to this ONE file
3. âœ… Export utility functions to format/filter the data as needed
4. âœ… Update all consumers to import from the central file
5. âœ… Verify no duplicates remain (grep for patterns)
6. âœ… Document the SSOT location in comments if non-obvious

### Warning Signs of SSOT Violation:

ğŸš¨ Same list appears in multiple files
ğŸš¨ Same constant defined in different places
ğŸš¨ Similar data structures with slight differences
ğŸš¨ When updating, need to change multiple files
ğŸš¨ Comments like "keep in sync with..."

**If you see these signs, immediately refactor to SSOT!**

---

## Separation of Concerns

**Each file/module handles ONE specific domain.**

### File Organization Rules:

1. **Services** (`services/`) - Business logic, external API calls
2. **Routes** (`routes/`) - HTTP handlers, request/response only
3. **Utils** (`utils/`) - Pure functions, no side effects
4. **Config** (`config/`) - Configuration, constants, prompts
5. **Models** (`models/`) - Data structures, database schemas

âŒ **Bad:** Mixed concerns
```javascript
// routes/whatsappRoutes.js
// âŒ Business logic in route handler!
router.post('/webhook', (req, res) => {
  const imageUrl = await generateImageWithGemini(prompt); // â† Should be in service!
  const text = translateText(imageUrl.caption, 'he'); // â† Should be in service!
  await sendToWhatsApp(chatId, imageUrl);
});
```

âœ… **Good:** Clear separation
```javascript
// routes/whatsappRoutes.js - Only routing
router.post('/webhook', async (req, res) => {
  const result = await agentService.processRequest(req.body);
  res.json(result);
});

// services/agentService.js - Business logic
async function processRequest(data) {
  const imageUrl = await imageService.generate(prompt);
  const text = await translationService.translate(imageUrl.caption, 'he');
  await whatsappService.send(chatId, imageUrl);
}
```

---

## Modularity & File Size

### File Size Limits:
- **Maximum 500 lines per file** (ideal: 200-300)
- **Maximum 50 lines per function** (ideal: 10-20)
- **Maximum 5 parameters per function** (use object for more)

### When to Split a File:

âœ… **Split when:**
- File exceeds 500 lines
- Multiple unrelated responsibilities
- Too many exports (>10)
- Hard to navigate or find code

**Example:** `agentService.js` is 3900+ lines â†’ **MUST** be split:
```
services/agent/
  â”œâ”€â”€ agentService.js        # Main orchestration (max 300 lines)
  â”œâ”€â”€ tools/
  â”‚   â”œâ”€â”€ imageTools.js      # Image-related tools
  â”‚   â”œâ”€â”€ searchTools.js     # Search-related tools
  â”‚   â””â”€â”€ locationTools.js   # Location-related tools
  â”œâ”€â”€ execution/
  â”‚   â”œâ”€â”€ singleStep.js      # Single step execution
  â”‚   â””â”€â”€ multiStep.js       # Multi-step execution
  â””â”€â”€ utils/
      â”œâ”€â”€ ackMessages.js     # Ack message building
      â””â”€â”€ contextBuilder.js  # Context building
```

---

## Code Complexity

### Cyclomatic Complexity Limits:
- **Maximum complexity: 10** per function
- **Ideal complexity: 1-5**

âŒ **Bad:** Too complex (complexity > 15)
```javascript
function processRequest(data) {
  if (data.type === 'text') {
    if (data.multiStep) {
      if (data.steps.length > 1) {
        for (let step of data.steps) {
          if (step.tool === 'image') {
            if (step.provider === 'gemini') {
              // ... 20 more nested ifs
            }
          }
        }
      }
    }
  }
}
```

âœ… **Good:** Low complexity (complexity < 5)
```javascript
function processRequest(data) {
  if (!isValid(data)) return handleError();
  
  return data.multiStep 
    ? processMultiStep(data)
    : processSingleStep(data);
}

function processMultiStep(data) {
  return data.steps.map(executeStep);
}
```

---

## Naming Conventions

### Variables & Functions:
- **camelCase** for variables/functions: `getUserData`, `isValid`
- **PascalCase** for classes: `UserService`, `ImageGenerator`
- **UPPER_SNAKE_CASE** for constants: `MAX_RETRIES`, `API_KEY`

### Naming Rules:
1. **Descriptive, not cryptic**: `userData` not `ud`
2. **Verbs for functions**: `generateImage`, `validateInput`
3. **Nouns for variables**: `userList`, `imageUrl`
4. **Boolean prefixes**: `isValid`, `hasError`, `shouldRetry`

âŒ **Bad:**
```javascript
function proc(d) {
  const x = d.t;
  const y = gen(x);
  return y;
}
```

âœ… **Good:**
```javascript
function processUserRequest(data) {
  const userText = data.text;
  const response = generateResponse(userText);
  return response;
}
```

---

## Error Handling

### Always Handle Errors Gracefully:

âœ… **Good:**
```javascript
try {
  const result = await riskyOperation();
  return result;
} catch (error) {
  console.error('âŒ Operation failed:', error.message);
  // Send error to user (Rule 2)
  await sendErrorToUser(chatId, error.message);
  return { success: false, error: error.message };
}
```

âŒ **Bad:**
```javascript
const result = await riskyOperation(); // â† No error handling!
```

---

## Performance Optimization

### 1. Avoid Unnecessary Work:
```javascript
// âœ… Good: Early return
if (!data) return;
if (!isValid(data)) return;
// ... expensive operations

// âŒ Bad: Do work then check
const result = expensiveOperation(data);
if (!data) return;
```

### 2. Use Caching:
```javascript
// âœ… Good: Cache expensive results
const cache = new Map();
function getExpensiveData(key) {
  if (cache.has(key)) return cache.get(key);
  const data = computeExpensiveData(key);
  cache.set(key, data);
  return data;
}
```

### 3. Parallelize Independent Operations:
```javascript
// âœ… Good: Parallel
const [image, video, audio] = await Promise.all([
  generateImage(prompt),
  generateVideo(prompt),
  generateAudio(prompt)
]);

// âŒ Bad: Sequential (3x slower!)
const image = await generateImage(prompt);
const video = await generateVideo(prompt);
const audio = await generateAudio(prompt);
```

---

## Code Comments

### When to Comment:
1. **Why**, not what: Explain reasoning, not obvious behavior
2. **Complex algorithms**: Explain the approach
3. **Workarounds**: Why you did something unusual
4. **TODOs**: What needs to be done (with context)

âœ… **Good:**
```javascript
// CRITICAL: Must send Ack BEFORE execution to prevent race condition
// where user sees output before knowing what's happening
await sendAck(chatId, tool);
await executeTool(tool);
```

âŒ **Bad:**
```javascript
// Send ack
await sendAck(chatId, tool); // â† Obvious!
```

---

## Testing Mindset

**Code should be written to be testable.**

âœ… **Testable:**
```javascript
// Pure function - easy to test
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

âŒ **Hard to test:**
```javascript
// Side effects everywhere
function processOrder() {
  const items = getItemsFromDatabase(); // â† Hard to mock
  const total = items.reduce((sum, item) => sum + item.price, 0);
  saveToDatabase(total); // â† Side effect
  sendEmail(user.email, total); // â† Side effect
}
```

---

## Refactoring Indicators

**Refactor when you see:**

1. ğŸš¨ **God Objects** - File/class doing too much
2. ğŸš¨ **Code Duplication** - Same logic in multiple places
3. ğŸš¨ **Long Functions** - Functions > 50 lines
4. ğŸš¨ **Deep Nesting** - Indentation > 4 levels
5. ğŸš¨ **Magic Numbers** - Unexplained constants in code
6. ğŸš¨ **Long Parameter Lists** - Functions with > 5 parameters
7. ğŸš¨ **Unclear Names** - Variables like `x`, `temp`, `data`

---

## Summary Checklist

Before committing, ask yourself:

- [ ] Is each file under 500 lines?
- [ ] Is each function under 50 lines?
- [ ] Does each module have a single responsibility?
- [ ] Is there any duplicated code? (DRY)
- [ ] Is there a Single Source of Truth for all data/config? (SSOT)
- [ ] Are all functions and variables named clearly?
- [ ] Is error handling comprehensive?
- [ ] Are concerns properly separated?
- [ ] Is the code optimized (no unnecessary work)?
- [ ] Would this be easy to test?
- [ ] Would a new developer understand this code?
- [ ] Can I reuse this code in other contexts? (Maximize reusability)

**If any answer is "no", refactor before committing.**

---

## Prompts & Acknowledgments Separation

**CRITICAL: All prompts and acknowledgment messages MUST be separated from business logic.**

This enforces SSOT and ensures consistency across all execution paths.

### Prompts Separation Rules:

1. **ALL prompts in `config/prompts.js`**:
   - System instructions for LLMs (Gemini, OpenAI, Grok)
   - Multi-step planner prompts
   - Agent routing prompts
   - Tool descriptions and examples
   
2. **Tool definitions in `config/tools-list.js`**:
   - Single source of truth for all tools
   - Descriptions, parameters, usage patterns
   - No duplication in other files

3. **Never hardcode prompts** in service files:

âŒ **Bad:**
```javascript
// services/imageService.js
const prompt = "Generate an image based on this description..."; // â† Hardcoded!
const result = await gemini.generate(prompt);
```

âœ… **Good:**
```javascript
// config/prompts.js
module.exports = {
  imageGeneration: (userPrompt) => `Generate an image: ${userPrompt}`
};

// services/imageService.js
const { imageGeneration } = require('../config/prompts');
const prompt = imageGeneration(userPrompt);
const result = await gemini.generate(prompt);
```

### Acknowledgment Messages (Acks) Rules:

**MUST be consistent across single-step AND multi-step execution.**

1. **Centralized Ack storage**:
   - WhatsApp Acks: `services/whatsapp/messaging.js` (sendAck function)
   - Agent Acks: `services/agent/config/constants.js` (TOOL_ACK_MESSAGES)

2. **Include provider names** where relevant:
   ```javascript
   TOOL_ACK_MESSAGES: {
     create_image: 'ğŸ¨ ×™×•×¦×¨ ×ª××•× ×” ×¢× __PROVIDER__...',
     create_video: 'ğŸ¬ ×™×•×¦×¨ ×•×™×“××• ×¢× __PROVIDER__...',
     edit_video: 'ğŸï¸ ×¢×•×¨×š ×•×™×“××• ×¢× Runway...' // Fixed provider
   }
   ```

3. **Same format for all paths**:
   - Single-step commands â†’ Use same Ack format
   - Multi-step commands â†’ Use same Ack format
   - Fallback attempts â†’ Send Ack for each provider

### Benefits:

âœ… **Maintainability**: Change once, apply everywhere  
âœ… **Consistency**: Same UX across all execution paths  
âœ… **Testability**: Easy to test prompt/Ack changes  
âœ… **Clarity**: Business logic stays clean  
âœ… **SSOT**: Single source for all user-facing text  

### Example: Wrong vs. Right

âŒ **Wrong:** Different Acks for same operation
```javascript
// Single-step handler
await sendTextMessage(chatId, 'ğŸ¨ ×§×™×‘×œ×ª×™! ××™×™×¦×¨ ×ª××•× ×”...'); // Different!

// Multi-step handler
await sendTextMessage(chatId, 'ğŸ¨ ×™×•×¦×¨ ×ª××•× ×” ×¢× Gemini...'); // Different!
```

âœ… **Right:** Consistent Acks everywhere
```javascript
// Both use the same central function
await sendAck(chatId, { type: 'create_image', provider: 'gemini' });
// â†’ "ğŸ¨ ×™×•×¦×¨ ×ª××•× ×” ×¢× Gemini..."
```

---

## Further Reading

- Clean Code by Robert C. Martin
- Refactoring by Martin Fowler
- Design Patterns by Gang of Four
- JavaScript: The Good Parts by Douglas Crockford
